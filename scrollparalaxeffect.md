# SCROLL PARALLAX EFFECT - Повна інструкція створення

## Зміст
1. [Концепція та принцип роботи](#концепція-та-принцип-роботи)
2. [HTML структура](#html-структура)
3. [CSS стилізація](#css-стилізація)
4. [JavaScript логіка](#javascript-логіка)
5. [Z-Index система](#z-index-система)
6. [Респонсивність та адаптація](#респонсивність-та-адаптація)
7. [Оптимізація продуктивності](#оптимізація-продуктивності)
8. [Секрети та підводні камені](#секрети-та-підводні-камені)

---

## Концепція та принцип роботи

### Основна ідея паралакс ефекту

Паралакс ефект створює ілюзію глибини та руху, коли різні шари контенту рухаються з різною швидкістю під час прокручування сторінки. У цьому проєкті використовується техніка фіксованого фону з рухомим контентом поверх нього.

### Три типи паралакс ефектів у проєкті

**Перший тип: Фіксоване відео як фон hero секції**
- Відео залишається нерухомим на екрані незалежно від скролу
- Контент hero секції скролиться разом зі сторінкою
- Наступні секції з'являються поверх відео з округленими кутами зверху

**Другий тип: Scroll-based активація секцій**
- JavaScript відстежує позицію скролу
- На основі скролу активується відповідна секція
- Кожна секція займає повну висоту екрану

**Третій тип: IntersectionObserver анімації**
- Елементи анімуються коли входять у видиму область екрану
- Використовується для карток, блоків контенту
- Плавна поява знизу вгору з затуханням

---

## HTML структура

### Базова структура hero секції з фіксованим відео

**Контейнер секції:**
Створіть основний контейнер секції з класом який позначає її як hero. Цей контейнер повинен мати клас що вказує на повну висоту екрану. Використовуйте семантичний тег section для правильної структури документа.

**Елементи відео:**
Всередині контейнера розмістіть два відео елементи - один для декстопу, інший для мобільних пристроїв. Кожному відео додайте клас для ідентифікації його призначення та базовий клас що позначає його як фоновий елемент. Обов'язково додайте атрибути для автоматичного відтворення, вимкнення звуку, зациклення та вбудованого відтворення на мобільних.

Важливо використовувати тег source всередині video з вказівкою на файл та тип. Для мобільних відео рекомендується менший розмір файлу та розширення.

**Overlay шар:**
Після відео додайте div елемент з класом overlay. Цей шар створює напівпрозоре затемнення поверх відео для кращої читабельності тексту. Він повинен покривати всю площу відео.

**Контент hero секції:**
Створіть контейнер для основного контенту hero секції. Всередині розмістіть wrapper контейнер для обмеження ширини. Далі створіть текстовий блок з:
- Заголовком першого рівня з основним повідомленням
- Параграфом з додатковим описом або списком послуг
- Блоком кнопок з call-to-action елементами

**Перша секція після hero:**
Одразу після hero секції створіть наступну секцію з особливим класом що позначає її як першу після hero. Ця секція повинна мати:
- Фоновий колір що контрастує з hero
- Достатній внутрішній відступ зверху
- Клас для округлення верхніх кутів
- Власний контент який буде скролитись поверх відео

### Структура для lazy loading відео у проектах

**Контейнер проекту:**
Створіть секцію-обгортку для всіх проектів. Всередині для кожного проекту створіть окремий div з атрибутом data що містить номер проекту.

**Елементи lazy відео:**
На відміну від hero відео, тут використовуйте атрибут data-src замість src. Додайте клас який позначає відео як lazy-loading. JavaScript перенесе значення з data-src в src коли відео стане видимим.

**Контент проекту:**
Кожна секція проекту повинна займати повну висоту екрану та містити:
- Контейнер для відео
- Контейнер з інформацією про проект
- Кнопки або посилання для взаємодії

### Атрибути та класи

**Обов'язкові атрибути для відео:**
- autoplay - автоматичний старт відтворення
- muted - вимкнення звуку обов'язкове для автоплею
- loop - безкінечне зациклення
- playsinline - важливо для iOS Safari
- preload - встановіть в auto для hero, none для lazy відео

**Система класів для відео:**
- Базовий клас для всіх фонових відео
- Клас для декстоп версії
- Клас для мобільної версії  
- Клас для lazy loading відео
- Класи контейнерів для правильного позиціонування

**Семантичні обгортки:**
Використовуйте section для основних блоків, article для проектів, div для технічних обгорток. Додавайте ARIA атрибути якщо потрібно для accessibility.

---

## CSS стилізація

### Базові стилі для hero контейнера

**Позиціонування та розміри:**
Hero секція повинна мати relative позиціонування щоб створити контекст для absolute та fixed дочірніх елементів. Ширина завжди сто відсотків. Мінімальна висота встановлюється як сто відсотків висоти viewport.

**Використання CSS змінних:**
Створіть CSS змінну для висоти viewport з назвою vh. Це критично важливо для iOS Safari де стандартна одиниця vh працює некоректно через адресний рядок що змінює розмір. Використовуйте calc функцію з множенням змінної vh на сто.

**Display властивості:**
Встановіть flex display для можливості центрування контенту. Align-items та justify-content в center дозволяють відцентрувати весь внутрішній контент по вертикалі та горизонталі.

**Overflow:**
Встановіть overflow hidden щоб запобігти виходу відео за межі контейнера.

### Стилізація фіксованого відео

**Position fixed - ключ до ефекту:**
Встановіть position fixed на відео елемент. Це найважливіша властивість що створює паралакс ефект. Відео залишається прикріпленим до viewport під час скролу.

**Покриття всього екрану:**
Встановіть координати top та left в нуль. Ширина та висота мають бути сто відсотків. Це забезпечує що відео покриває весь видимий екран.

**Object-fit cover:**
Критично важлива властивість для відео та зображень. Вона забезпечує що контент заповнює всю область зберігаючи пропорції. Відео обрізається по краях якщо потрібно але не розтягується.

**Z-index для фону:**
Встановіть негативне значення z-index, наприклад мінус один. Це поміщає відео під весь інший контент. Використовуйте CSS змінну для централізованого управління.

**Pointer events:**
Можете додати pointer-events none щоб відео не перехоплювало кліки мишки та touch події.

### Стилізація overlay шару

**Позиціонування:**
Overlay повинен мати absolute позиціонування. Координати top left width height всі встановлені відповідно щоб покрити всю батьківську область.

**Фоновий колір з прозорістю:**
Використовуйте rgba функцію для чорного кольору з альфа каналом. Типове значення альфа від нуль цілих чотири до нуль цілих шість. Це створює легке затемнення що покращує читабельність білого тексту.

**Z-index:**
Встановіть z-index вище ніж у відео але нижче ніж у контенту. Рекомендоване значення один.

**Pointer events:**
Додайте pointer-events none щоб overlay не блокував взаємодію з кнопками контенту.

### Стилізація контенту hero секції

**Позиціонування та z-index:**
Контент має relative позицію. Z-index встановіть значно вище - рекомендується десять або більше. Це гарантує що контент буде поверх відео та overlay.

**Ширина та padding:**
Ширина сто відсотків з внутрішніми відступами зліва справа. Вертикальні відступи створюють повітря навколо контенту. Використовуйте CSS змінні для spacing.

**Pointer events auto:**
Явно встановіть pointer-events auto щоб контент був інтерактивним навіть якщо батьківські елементи мають pointer-events none.

**Текстові стилі:**
Заголовки зробіть великими жирними з негативним letter-spacing. Додайте text-shadow для покращення читабельності поверх відео. Тінь повинна бути м'якою та ненав'язливою.

### Стилізація першої секції після hero

**Ключові властивості для ефекту:**
Встановіть relative позицію та обов'язково z-index вище ніж у hero контенту. Рекомендоване значення десять або вище. Це критично важливо щоб секція з'являлась поверх фіксованого відео.

**Фон та оформлення:**
Додайте щільний фоновий колір без прозорості. Типово використовується темний колір для контрасту з hero секцією.

**Border-radius для верхніх кутів:**
Використовуйте border-radius з двома значеннями - для верхнього лівого та правого кута. Типове значення двадцять пікселів. Нижні кути залишаються гострими тому вказуються нулі.

**Негативний margin-top:**
Додайте негативний верхній margin того ж значення що й border-radius. Це створює ефект накладання секції на hero та плавного переходу.

**Box-shadow:**
Додайте тінь зверху для створення глибини. Використовуйте негативне значення y-offset та розмиття. Колір тіні чорний з прозорістю.

**Внутрішній padding зверху:**
Встановіть достатній padding-top щоб контент не був затиснутий біля округленого краю. Рекомендується шістдесят пікселів або більше.

### Респонсивні класи для відео

**Desktop відео:**
Створіть клас для декстоп версії з display block за замовчуванням. У медіа запиті для мобільних пристроїв встановіть display none.

**Mobile відео:**
Створіть клас для мобільної версії з display none за замовчуванням. У медіа запиті для мобільних встановіть display block.

**Медіа запити:**
Використовуйте точку розриву сімсот шістдесят сім пікселів. Все що нижче вважається мобільним. Все вище показує декстоп версію.

### Анімації для контенту

**Keyframes для fadeInUp:**
Створіть анімацію з іменем fadeInUp. У стані from встановіть opacity нуль та transform translateY з позитивним значенням тридцять пікселів. У стані to opacity один та translateY нуль.

**Застосування анімації:**
До заголовка додайте animation з назвою fadeInUp тривалістю одна секунда timing функцією ease-out. Встановіть animation-delay відповідно для послідовної появи елементів.

**Каскадні затримки:**
Перший елемент нуль цілих три секунди затримки. Другий елемент нуль цілих шість секунд. Третій елемент нуль цілих дев'ять секунд. Це створює ефект послідовної появи.

**Animation fill mode:**
Встановіть animation-fill-mode both щоб елементи зберігали стилі до та після анімації. Це запобігає миготінню на початку.

**Prefers-reduced-motion:**
Обгорніть всі анімації у медіа запит prefers-reduced-motion no-preference. Це поважає налаштування користувачів які вимкнули анімації.

**Fallback стилі:**
За замовчуванням без анімацій встановіть opacity один та transform none щоб контент був видимий навіть якщо анімації не підтримуються.

---

## JavaScript логіка

### Ініціалізація відео системи

**Перевірка готовності DOM:**
Обгорніть весь код у слухач події DOMContentLoaded. Це гарантує що HTML повністю завантажений перед виконанням скриптів.

**Альтернативна перевірка:**
Перевірте document.readyState. Якщо він не дорівнює loading то DOM вже готовий та можна викликати функції одразу. Інакше додайте слухач події.

**Клас або модульний підхід:**
Створіть клас для управління відео системою. Конструктор ініціалізує властивості об'єкта. Використовуйте Map для зберігання відео елементів та їх даних.

**Властивості системи:**
Створіть властивості для зберігання списку відео, стану автоплею, стратегії завантаження, та observers. Встановіть початкові значення в null до визначення.

### Визначення підтримки автоплею

**Створення тестового відео:**
Програмно створіть video елемент. Встановіть muted та playsInline в true. Додайте inline стилі для приховання елемента за межами екрану.

**Тестове відео джерело:**
Використовуйте data URI з мінімальним base64 закодованим відео. Це дозволяє протестувати автоплей без завантаження реального файлу.

**Додавання до DOM:**
Тимчасово додайте тестовий video до body. Це необхідно бо деякі браузери не дозволяють автоплей для елементів що не в DOM.

**Спроба відтворення:**
Викличте метод play на відео елементі. Метод повертає Promise. Обробіть Promise за допомогою async await або then catch.

**Очищення:**
Після тесту видаліть елемент з DOM викликавши remove. Поверніть true якщо відтворення успішне або false якщо помилка.

**Збереження результату:**
Збережіть результат тесту у властивість об'єкта. Використовуйте це значення надалі для прийняття рішень про автоплей.

### Обробка відео на сторінці

**Пошук стандартних відео:**
Використовуйте querySelectorAll для пошуку всіх відео які не мають клас lazy. Селектор повинен шукати елементи з базовим класом фонового відео або hero відео.

**Ітерація та обробка:**
Пройдіться циклом по знайдених елементах. Для кожного відео викличте функцію обробки передаючи елемент та режим standard.

**Пошук lazy відео:**
Окремим запитом знайдіть всі відео з класом lazy. Ці відео не повинні завантажуватись одразу.

**Реєстрація lazy відео:**
Для кожного lazy відео створіть об'єкт даних з елементом, режимом lazy, та флагами loaded і playing встановленими в false. Збережіть в Map структурі.

**Оптимізація атрибутів:**
Для кожного відео встановіть muted true, playsInline true, loop true, controls false. Додайте атрибути playsinline та webkit-playsinline для iOS.

**Preload стратегія:**
Для мобільних пристроїв встановіть preload в metadata або none. Для декстопу стандартних відео встановіть auto. Для lazy завжди none.

### IntersectionObserver для lazy loading

**Створення observer:**
Перевірте чи підтримується IntersectionObserver у window об'єкті. Якщо ні то пропустіть цю логіку.

**Конфігурація observer:**
Створіть новий IntersectionObserver передаючи callback функцію та опції. В опціях встановіть rootMargin для передзавантаження та threshold для чутливості.

**RootMargin значення:**
Використовуйте позитивне значення наприклад сто пікселів. Це означає що відео почне завантажуватись за сто пікселів до появи в viewport.

**Threshold значення:**
Встановіть порогове значення наприклад нуль цілих два. Це означає що callback спрацює коли двадцять відсотків елемента стане видимим.

**Callback функція:**
В callback обробіть масив entries. Для кожного entry перевірте властивість isIntersecting. Якщо true то елемент став видимим.

**Завантаження відео:**
Коли елемент став видимим викличте функцію завантаження відео. Передайте елемент або знайдіть відео всередині елемента.

**Відписка від observer:**
Після завантаження відео відпишіться від спостереження викликавши unobserve на цьому елементі. Це економить ресурси.

### Завантаження відео

**Перевірка data-src:**
Перевірте чи має елемент атрибут data-src. Якщо так то отримайте значення та встановіть його в src.

**Обробка source елементів:**
Знайдіть всі source елементи всередині відео. Для кожного перевірте data-src та перенесіть значення в src.

**Видалення атрибутів:**
Після перенесення видаліть data-src атрибути. Також видаліть клас lazy-video з елемента.

**Виклик load:**
Явно викличте метод load на відео елементі. Це запускає процес завантаження медіа файлу.

**Очікування готовності:**
Створіть Promise який резолвиться коли відео готове до відтворення. Слухайте подію loadeddata або перевірте readyState.

**ReadyState перевірка:**
Якщо readyState більше або дорівнює два то дані вже завантажені. Одразу резолвіть Promise без очікування події.

**Timeout захист:**
Створіть setTimeout який reject Promise через певний час наприклад десять секунд. Це запобігає зависанню якщо відео не завантажується.

**Очищення слухачів:**
Після завантаження або помилки видаліть всі event listeners та очистіть timeout. Це запобігає витокам пам'яті.

**Спроба автоплею:**
Якщо підтримується автоплей викличте метод play обгорнувши в try catch або обробивши Promise rejection.

### Scroll tracking для активації секцій

**Отримання позиції скролу:**
Використовуйте window.pageYOffset для отримання поточної позиції скролу. Для сумісності додайте fallback на document.documentElement.scrollTop.

**Розрахунок висоти hero:**
Отримайте висоту hero секції викликавши offsetHeight на елементі. Збережіть це значення для подальших розрахунків.

**Скрол після hero:**
Віднімайте висоту hero від поточної позиції скролу. Використовуйте Math.max з нулем щоб уникнути негативних значень.

**Розрахунок індексу секції:**
Поділіть скрол після hero на висоту однієї секції. Використовуйте Math.floor для округлення вниз. Обмежте значення кількістю секцій мінус один.

**Порівняння з попереднім:**
Збережіть попередній активний індекс. Порівнюйте новий індекс з попереднім. Оновлюйте тільки якщо значення змінилось.

**Оновлення активного стану:**
Пройдіться по всіх секціях. Додайте клас active до секції з поточним індексом. Видаліть клас active з інших секцій.

**RequestAnimationFrame:**
Обгорніть логіку оновлення в requestAnimationFrame. Це синхронізує оновлення з браузерним рендерингом та покращує продуктивність.

**Throttling:**
Використовуйте флаг ticking щоб запобігти множинним викликам requestAnimationFrame. Встановлюйте флаг в true при запиті та скидайте в false в callback.

### Event listeners для відео

**Visibility change:**
Слухайте подію visibilitychange на document. Коли сторінка стає прихованою зупиняйте всі відео. Коли повертається відновлюйте відтворення.

**Перевірка document.hidden:**
В обробнику перевірте властивість document.hidden. Якщо true викличте метод паузи всіх відео. Якщо false викличте метод відновлення.

**Connection change:**
Якщо доступний navigator.connection слухайте подію change. При поганому з'єднанні зупиняйте відео для економії трафіку.

**Effective type перевірка:**
Перевірте connection.effectiveType. Якщо значення slow-2g або 2g зупиніть всі відео. Користувач на повільному з'єднанні.

**Орієнтація пристрою:**
Слухайте orientationchange на window. При зміні орієнтації може знадобитися перерахувати висоту viewport та оновити CSS змінні.

**Resize обробка:**
Слухайте resize але з debounce. Створіть timeout що очищується кожен раз. Виконуйте логіку тільки після паузи в сто мілісекунд.

---

## Z-Index система

### Концепція шарування

**Стратегія централізованих значень:**
Створіть окремий CSS файл для z-index системи. Визначте всі значення як CSS custom properties в root селекторі. Це дозволяє легко управляти всією ієрархією з одного місця.

**Ієрархія рівнів:**
Визначте рівні від найнижчого до найвищого. Фонові елементи отримують негативні значення. Основний контент отримує низькі позитивні значення. Навігація отримує високі значення. Модальні вікна найвищі значення.

### Рівні для паралакс системи

**Фонове відео:**
Встановіть змінну для фонового рівня з значенням мінус один. Це найнижчий можливий рівень що тримає відео під всім іншим контентом.

**Overlay шар:**
Створіть змінну для overlay з значенням один. Це поміщає затемнення поверх відео але під контентом.

**Hero контент:**
Встановіть змінну для hero контенту зі значенням сто або десять. Це достатньо високо щоб бути поверх відео та overlay але нижче навігації.

**Перша секція:**
Змінна для першої секції після hero повинна мати значення десять або вище. Критично важливо щоб вона була вища за hero контент інакше не перекриє фіксоване відео.

**Навігація:**
Встановіть змінну для навігації зі значенням тисяча. Це забезпечує що header завжди видимий поверх всього контенту включаючи секції що скролятся.

**Мобільне меню:**
Змінна для мобільного меню має значення десять тисяч. Це найвищий рівень інтерфейсу крім модальних вікон.

**Модальні вікна:**
Backdrop модального вікна отримує значення дві тисячі. Контент модального вікна дві тисячі один. Це найвищий можливий рівень інтерфейсу.

### Застосування змінних

**Використання в компонентах:**
В CSS файлах компонентів використовуйте var функцію для отримання значення змінної. Наприклад z-index var дефіс дефіс z-background.

**Fallback значення:**
Після коми в var функції можна вказати fallback значення. Якщо змінна не визначена використається це значення. Наприклад var дефіс дефіс z-background comma мінус один.

**Уникнення магічних чисел:**
Ніколи не використовуйте прямі числові значення z-index в компонентах. Завжди посилайтесь на змінні. Це робить систему передбачуваною та легкою в підтримці.

### Ізоляція stacking context

**Isolation властивість:**
Для секцій що містять складну структуру встановіть isolation isolate. Це створює новий stacking context без використання z-index.

**Transform створює context:**
Пам'ятайте що transform властивість автоматично створює новий stacking context. Елементи з transform можуть поводитись неочікувано з z-index.

**Position створює context:**
Будь-яке значення position крім static разом з z-index створює stacking context. Плануйте це при проектуванні структури.

---

## Респонсивність та адаптація

### Viewport одиниці для мобільних

**Проблема стандартного vh:**
На мобільних пристроях особливо iOS Safari стандартна одиниця vh працює некоректно. Браузерний UI показується та ховається під час скролу змінюючи висоту viewport.

**JavaScript розрахунок:**
В JavaScript отримайте window.innerHeight та помножте на нуль цілих нуль один. Це дає один відсоток висоти в пікселях. Встановіть як CSS змінну.

**Встановлення змінної:**
Використовуйте document.documentElement.style.setProperty для встановлення custom property. Перший параметр назва дефіс дефіс vh другий параметр значення з одиницею px.

**Оновлення при resize:**
Створіть функцію що оновлює змінну. Викликайте її при resize та orientationchange подіях. Додайте debounce для оптимізації.

**Використання в CSS:**
В CSS використовуйте calc функцію з var дефіс дефіс vh помножене на сто. Це дає повну висоту viewport враховуючи браузерний UI.

**Fallback на стандартний vh:**
Встановіть min-height спочатку зі стандартним сто vh потім з calc кастомної змінної. Браузери що не підтримують custom properties використають перше значення.

### Адаптація відео

**Різні файли для пристроїв:**
Підготуйте дві версії кожного відео - для декстопу та мобільних. Мобільна версія повинна бути меншого розміру та розширення.

**Показ правильного відео:**
Використовуйте медіа запит для перемикання display між декстоп та мобільною версією. Точка розриву сімсот шістдесят сім пікселів.

**Preload стратегія:**
На мобільних встановіть preload в metadata або none. На декстопі можна auto для критичних відео. Lazy відео завжди none.

**Перевірка з'єднання:**
Якщо доступний Network Information API перевірте effectiveType. На повільному з'єднанні не завантажуйте відео автоматично.

### Адаптація розмірів

**Мега заголовки:**
На декстопі використовуйте розміри від ста двадцяти до ста шістдесяти пікселів. На планшетах зменшіть до вісімдесяти ста пікселів. На мобільних сорок шістдесят пікселів.

**Padding та margin:**
На декстопі використовуйте великі значення шістдесят вісімдесят пікселів. На мобільних зменшіть до тридцяти сорока пікселів зберігаючи пропорції.

**Border radius:**
Перша секція після hero на декстопі має border-radius двадцять пікселів. На мобільних зменшіть до шістнадцяти пікселів для кращої естетики.

**Негативний margin:**
Відповідно зменшіть негативний margin-top першої секції щоб співпадав з border-radius на кожному breakpoint.

### iOS Safari специфіка

**Safe area insets:**
Використовуйте env safe-area-inset для врахування вирізу на iPhone. Додайте до padding значення env safe-area-inset-top та bottom.

**Webkit fill available:**
Для height можна використати webkit-fill-available як альтернативу vh на iOS. Додайте як fallback після стандартного значення.

**Fixed позиція обмеження:**
На iOS Safari fixed position має обмеження особливо в landscape режимі. Для дуже низьких екранів перемкніть fixed на absolute.

**Landscape mode медіа запит:**
Створіть медіа запит max-height п'ятсот пікселів та orientation landscape. В ньому змініть position відео з fixed на absolute.

**Touch callout:**
Використовуйте supports запит для webkit-touch-callout none щоб виявити iOS. В цьому блоці додайте специфічні стилі для iOS.

---

## Оптимізація продуктивності

### GPU прискорення

**Transform замість top left:**
Для анімованих елементів використовуйте transform замість зміни top left властивостей. Transform обробляється GPU що значно швидше.

**TranslateZ hack:**
Додайте transform translateZ нуль до елементів які хочете прискорити. Це примусово активує GPU прискорення навіть без реальної трансформації.

**Will-change властивість:**
На елементах які будуть анімуватись встановіть will-change з переліком властивостей. Наприклад will-change transform opacity. Не зловживайте цим.

**Обмеження will-change:**
Встановлюйте will-change тільки безпосередньо перед анімацією та видаляйте після. Постійне використання спричиняє витік пам'яті.

### Debounce та throttle

**Scroll обробка:**
Scroll події спрацьовують дуже часто. Використовуйте throttle щоб обмежити частоту виконання callback. Оптимальна затримка п'ятдесят сто мілісекунд.

**Resize обробка:**
Resize події також спрацьовують часто. Використовуйте debounce щоб виконати callback тільки після паузи. Затримка сто двісті мілісекунд.

**RequestAnimationFrame throttle:**
Для scroll обробки комбінуйте throttle з requestAnimationFrame. Використовуйте флаг ticking щоб запобігти множинним запитам анімації в одному фреймі.

### Lazy loading стратегії

**IntersectionObserver перевага:**
Завжди надавайте перевагу IntersectionObserver над scroll обробкою для виявлення видимості. Він оптимізований браузером та працює асинхронно.

**RootMargin для передзавантаження:**
Встановіть позитивний rootMargin наприклад сто або двісті пікселів. Це запускає завантаження трохи раніше ніж елемент стане видимим.

**Threshold налаштування:**
Для критичного контенту встановіть низький threshold наприклад нуль цілих нуль один. Для некритичного можна вище нуль цілих три нуль цілих п'ять.

**Unobserve після завантаження:**
Одразу після завантаження елемента відпишіться від observer. Це звільняє ресурси та покращує продуктивність на сторінках з великою кількістю елементів.

### Оптимізація відео

**Компресія файлів:**
Використовуйте сучасні кодеки для максимальної компресії. H264 для сумісності H265 для меншого розміру. Налаштуйте bitrate відповідно до якості.

**Множинні версії:**
Створіть версії для декстопу та мобільних з різними розширеннями та bitrate. Мобільна версія може бути значно меншою.

**Poster image:**
Встановіть poster атрибут на відео з зображенням першого кадру. Це покращує perceived performance поки відео завантажується.

**Preload стратегії:**
Критичні відео hero секцій встановіть preload auto. Lazy відео встановіть none. Відео нижче fold встановіть metadata.

### CSS оптимізації

**Contain властивість:**
На секціях встановіть contain layout style. Це повідомляє браузеру що зміни всередині секції не впливають на зовнішні елементи.

**Content-visibility:**
Експериментальна властивість content-visibility auto може значно покращити продуктивність на довгих сторінках. Браузер пропускає рендеринг прихованих секцій.

**Transform на анімованих елементах:**
Всі елементи з анімаціями повинні використовувати transform та opacity. Ці властивості не викликають reflow та можуть бути оптимізовані GPU.

---

## Секрети та підводні камені

### Критичні моменти для роботи паралаксу

**Z-index першої секції:**
Найпоширеніша помилка недостатній z-index на першій секції після hero. Він має бути вищий за hero контент інакше секція не перекриє фіксоване відео.

**Щільний фон першої секції:**
Перша секція повинна мати непрозорий фон. Навіть мінімальна прозорість зруйнує ефект бо крізь неї буде видно фіксоване відео знизу.

**Position relative на секціях:**
Всі секції після hero повинні мати position relative або absolute щоб z-index працював. Статичне позиціонування ігнорує z-index.

**Overflow на body:**
Не встановлюйте overflow hidden на body якщо використовуєте fixed відео. Це може заблокувати скрол або викликати дивну поведінку.

### Мобільні пристрої особливості

**Autoplay обмеження:**
Більшість мобільних браузерів блокують автоплей відео. Обов'язково встановіть muted та playsinline атрибути. Навіть тоді автоплей може не спрацювати.

**Перевірка підтримки автоплею:**
Завжди перевіряйте чи підтримується автоплей перед спробою відтворення. Використовуйте тестове відео в JavaScript для визначення.

**Низька потужність пристроїв:**
На старих або дешевих пристроях відео може лагати або взагалі не відтворюватись. Підготуйте fallback у вигляді статичного зображення.

**Енергоспоживання:**
Відео споживає багато енергії батареї. На мобільних розгляньте використання зображень замість відео або зупинку відео коли сторінка неактивна.

### iOS Safari підводні камені

**Viewport height проблема:**
Це найбільша проблема iOS Safari. Стандартний vh включає висоту браузерного UI який ховається при скролі. Завжди використовуйте JavaScript розрахунок.

**Fixed position обмеження:**
В деяких версіях iOS Safari fixed position працює некоректно особливо в landscape. Підготуйте fallback з absolute для низьких екранів.

**Video rendering bugs:**
Іноді відео може мерехтіти або некоректно відображатись. Додавання webkit transform translateZ нуль часто вирішує проблему.

**Memory leaks:**
iOS Safari агресивно керує пам'яттю. Великі відео можуть бути вивантажені з пам'яті. Слухайте події та перезавантажуйте відео якщо потрібно.

### Продуктивність критичні помилки

**Scroll обробка без throttle:**
Виконання складної логіки на кожній події scroll без throttle блокує головний потік та спричиняє лаги.

**Forced reflow в циклі:**
Читання offsetHeight width або інших layout властивостей в циклі спричиняє forced reflow на кожній ітерації. Кешуйте значення.

**Множинні requestAnimationFrame:**
Виклик requestAnimationFrame множинних разів в одному scroll обробнику марнує ресурси. Використовуйте флаг для запобігання дублікатів.

**Великі z-index значення:**
Використання надмірно великих z-index наприклад дев'ять дев'ять дев'ять дев'ять дев'ять спричиняє проблеми з stacking context та може уповільнити композицію.

### Доступність considerations

**Prefers-reduced-motion:**
Завжди перевіряйте медіа запит prefers-reduced-motion. Користувачі з motion sickness повинні мати можливість вимкнути анімації.

**Keyboard navigation:**
Переконайтесь що всі інтерактивні елементи поверх відео доступні через клавіатуру. Fixed позиціонування може порушити tab order.

**Screen reader підтримка:**
Додайте відповідні ARIA атрибути та alt тексти. Переконайтесь що декоративні елементи приховані від screen readers через aria-hidden.

**Контраст тексту:**
Текст поверх відео має достатній контраст. Використовуйте overlay та text-shadow для забезпечення читабельності.

### Fallback стратегії

**Відсутність JavaScript:**
Підготуйте noscript fallback або переконайтесь що базовий контент видимий навіть без JavaScript. Критичний контент не повинен залежати від JS.

**Старі браузери:**
Перевіряйте підтримку сучасних API перед використанням. Надайте альтернативну поведінку для браузерів без IntersectionObserver або custom properties.

**Статичне зображення fallback:**
Для відео завжди підготуйте poster зображення. Якщо відео не завантажується або не відтворюється користувач побачить хоча б статичну картинку.

**Прогресивне покращення:**
Базова функціональність працює без паралакс ефектів. Паралакс додається як покращення для браузерів та пристроїв що підтримують необхідні технології.

---

## Додаткові рекомендації

### Тестування

**Множинні пристрої:**
Тестуйте на реальних пристроях не тільки в емуляторі. iOS Safari може поводитись зовсім інакше ніж показує Chrome DevTools.

**Різні розміри екрану:**
Перевірте всі breakpoint та проміжні розміри. Особливу увагу приділіть landscape орієнтації на мобільних.

**Повільне з'єднання:**
Тестуйте на повільному з'єднанні використовуючи DevTools throttling. Переконайтесь що сторінка залишається функціональною під час завантаження відео.

**Різні браузери:**
Перевірте мінімум Chrome Safari Firefox та Edge. Mobile Safari та Chrome на Android мають різну поведінку.

### Підтримка коду

**Документація:**
Документуйте критичні моменти та нестандартні рішення. Майбутні розробники повинні розуміти чому код написаний саме так.

**CSS змінні:**
Використовуйте CSS custom properties для всіх магічних чисел. Це робить систему гнучкою та легкою в налаштуванні.

**Модульність:**
Розділіть CSS на окремі файли по компонентах. Базові стилі паралаксу в одному файлі специфічні стилі сторінок в інших.

**Версіонування:**
Використовуйте версіонування для відео та CSS файлів щоб уникнути проблем з кешуванням при оновленнях.

### Метрики та моніторинг

**Performance API:**
Використовуйте Performance API для вимірювання часу завантаження та відтворення відео. Логуйте метрики для аналізу.

**Error tracking:**
Відстежуйте помилки завантаження відео та проблеми з автоплеєм. Це допоможе виявити проблеми на конкретних пристроях або браузерах.

**User timing:**
Використовуйте performance.mark та performance.measure для вимірювання критичних моментів завантаження та ініціалізації.

### Майбутні покращення

**WebM формат:**
Розгляньте підтримку WebM формату з VP9 або AV1 кодеками для кращої компресії. Надайте MP4 як fallback.

**Adaptive streaming:**
Для великих проектів розгляньте використання HLS або DASH для адаптивного streaming відео залежно від швидкості з'єднання.

**Service Worker:**
Використовуйте Service Worker для кешування критичних відео та покращення offline досвіду.

**Intersection Observer v2:**
Нова версія API надає більше інформації про видимість включаючи частковість перекриття іншими елементами.

---

## Заключення

Створення якісного scroll parallax ефекту вимагає ретельної роботи на всіх рівнях від HTML структури до JavaScript логіки. Ключ до успіху це розуміння базових принципів роботи fixed positioning z-index системи та viewport особливостей мобільних браузерів.

Найважливіші моменти які потрібно запам'ятати:

**Технічна основа:**
- Fixed position на відео з негативним z-index
- Достатньо високий z-index на секціях що скролятся
- Непрозорий фон на секціях поверх відео
- Правильна обробка viewport висоти особливо на iOS

**JavaScript інтеграція:**
- IntersectionObserver для lazy loading
- RequestAnimationFrame для плавних оновлень
- Перевірка підтримки автоплею
- Обробка помилок та fallback сценарії

**Адаптивність:**
- Різні відео для декстопу та мобільних
- Перерахунок розмірів при resize
- Special handling для iOS Safari
- Поважання prefers-reduced-motion

**Оптимізація:**
- GPU прискорення через transform
- Throttle та debounce для обробників подій
- Lazy loading некритичних ресурсів
- Contain для ізоляції секцій

Дотримуючись цих принципів та рекомендацій ви зможете створити надійний та продуктивний паралакс ефект що працює на всіх пристроях та браузерах. Пам'ятайте що основа це семантична HTML структура чистий CSS без хаків та продуманий JavaScript який покращує а не замінює базову функціональність.

